[{"content":"IPv6 中一种基于卷积的 DDoS 攻击两阶段防御机制 研究现状 现有的研究内容： 在DDoS攻击防御工作中，针对DDoS攻击事件的监控研究逐渐受到重视。早期的研究，如Yuan等人[14]提出通过在网络中设置互相关观察点，监控DDoS攻击在宏观上引起的时空流量模式变化。Singh等人[15]通过监控流经边缘路由器的流量，设置归一化路由器熵、数据包速率和熵速率阈值，实时监控DDoS行为。Liu等人[16]基于模糊控制理论和统计理论，建立正常传输行为模型，实现网络监控和预警功能。随后，Liu等人[17]提出名为UnivMon的流量监测框架，基于草图理论使用数据平面中的流统计信息来计算应用程序级指标，在一系列监控任务中实现了高准确性。\n其他研究还包括基于SDN的流量全局信息提出DDoS攻击缓解架构[18]、基于熵的有状态数据平面监控物联网中的DDoS攻击[19]、基于隐半马尔可夫模型的异常检测器[20]、以及基于虚拟机的分层聚类方法提升实时监控性能[21]。\n总体来看，DDoS攻击的监控手段正从宏观观察逐渐发展到基于IP熵等流量统计学指标，再到引入聚类、马尔可夫链、支持向量机等人工智能分析手段。未来的研究应引入更为优秀、更贴合DDoS攻击监控场景的人工智能核心，探讨提升监控实时性。\nDDoS攻击流量过滤研究的重点在于区分网络中混杂的DDoS流量报文，在监控到攻击发生后，有效提取DDoS流量的来源，基于此下发针对性的流量阻断策略以缓解攻击。\n近年来，大量工作引入人工智能模型作为检测核心。Yuan等人[24]提出基于深度学习的DDoS攻击检测方法DeepDefense，主要利用循环神经网络（RNN）实现高级特征提取，较传统机器学习方法有更高准确度。Rehman等人[25]提出名为DIDDOS的新型高效策略，使用基于门控循环单元（GRU）的RNN网络抵御现实世界中的新型DDoS攻击。Ali等人[26]提出一种快速、大规模的监控系统，获取DDoS攻击发生时的暗网流量，形成数据集进行训练和检测。Saad等人[27]在IPv6网络中提出使用反向传播神经网络的智能ICMPv6 DDoS攻击检测框架v6IIDS。\n其他研究还包括基于SVM分类算法建立DDoS攻击模型[28]、基于云的分布式深度学习框架实现物联网安全[29]、轻量级DoS检测方案DLDM[30]、实用的轻量级深度学习DDoS检测系统Lucid[31]、以及结合CNN和RNN的分层时空特征学习异常检测方法HAST-NAD[35]。\n尽管深度模型在检测攻击类型广泛性、准确率和时间序列感知力等方面具有优势，但随着网络场景的复杂化，深度学习模型的使用应考虑轻量化问题，尝试引入结构更轻、开销更低的新颖技术来解决问题[36]。\n现有研究存在的问题： 这些研究现状的问题主要体现在以下两个方面：\n当前的DDoS攻击监控手段在实时性和适应性上存在不足。虽然研究已经从宏观观察发展到使用IP熵等统计指标，再到引入聚类、马尔可夫链和支持向量机等人工智能方法，但这些方法可能无法及时响应新型和复杂的攻击场景。它们在高流量、高速率的网络环境中可能性能下降，无法满足对实时监控和快速预警的需求。因此，需要引入更先进、更适合DDoS攻击监控场景的人工智能核心技术，以提高监控的实时性和准确性。\n在DDoS攻击流量过滤方面，虽然深度学习模型如RNN、CNN等在攻击检测中表现出高准确率和广泛的检测能力，但其模型复杂度高，计算和存储开销大。这使得它们在实际部署中面临挑战，尤其是在资源受限的环境中。此外，随着网络场景的复杂化，这些深度模型可能无法有效处理新的攻击手段，且缺乏对模型轻量化和高效性的关注。因此，需要开发结构更轻、资源消耗更低的新技术，以实现高效、可扩展的DDoS流量过滤，同时保证检测性能。\n总体设计 两阶段防御机制结构如图1所示，包含4个部分: IPv6-SAVI实验拓扑, IPv6流量预处理策略, 检测模型构建 和 两阶段DDoS攻击防御策略。\n本文在东北大学校园网的CERNET2服务器上搭建了IPv6-LAN拓扑作为实验环境，引入IPv4公开流量集CIC-DDoS2019，并通过NAT 4to6翻译技术在IPv6-LAN中重放，模拟纯IPv6的DDoS攻击流量源，解决了IPv6环境下公开DDoS流量集匮乏的问题。\n我们设计了IPv6流量预处理策略，将捕获的原始流量解析为可输入深度学习模型的样本格式，包括针对BCNN模型的流量矩阵和针对1DCNN模型的一维报文。基于DDoS防御中事件监控和流量过滤的不同需求，构建了两种不同的卷积神经网络检测模型：BCNN和1DCNN，作为决策核心。最终，提出了两阶段的DDoS攻击防御策略，在IPv6流量预处理和检测模型的基础上，实现了DDoS攻击的快速防御，包括利用BCNN模型进行预检测，实时监控网络流量并告警DDoS攻击的发生，以及在告警后利用1DCNN模型逐条区分和过滤混杂的DDoS报文。\nIPv6 流量预处理策略 IPv6 报文头部信息提取 IPv6流量预处理策略旨在将网络中捕获的原始IPv6流量数据处理成可输入本文构建的深度学习检测模型的格式。在实验中，我们使用Wireshark作为流量捕捉器，以PCAP格式抓取网络中的IPv6流量，然后解析并存储报文的头部信息进行分析。\n为了提升流量信息的提取速度，我们基于IPv6报文头部定长的特点，设计了解析流程，直接提取PCAP中的16进制原始报文字段作为样本数据，省去了传统的报文信息转译等步骤。PCAP文件以固定长度为24字节的文件头开始，记录了当前文件捕获的时间跨度和报文数量等信息。随后是依次存储的报文数据，每个报文由固定长度为16字节的帧信息部分和可变长度的内容部分组成。帧信息部分记录了包的到达时间、经历时间和捕获长度等信息；内容部分包含报文的头部信息和负载数据。图2中的报文，在第1个报文中, 帧信息部分的第 13 和 14 字节以倒序存储当前报文内容的长度。\n我们通过跳过PCAP文件头，在每个报文的帧信息部分读取报文长度，从而提取完整的报文内容。根据报文信息的特定字节（如第21字节的值），匹配当前报文的类型（例如，“11”表示ICMPv6报文）。利用IPv6不同报文类型的头部定长特点，我们能够截取对应报文的完整头部信息。本文研究了ICMPv6、TCP和UDP这三种报文类型，它们也是DDoS防御中最常分析的三种类型。表 1 展示了这三种类型报文的不同字段及其在头部中的对应位置，包括以太网和 IPv6 的共有字段以及各类型报文的特殊字段。总结如表1所示：\n模型输入样本设计 图4所示, 在本文中, 我们将IPv6正常流量和DDoS攻击流量混合作为数据源. 针对BCNN模型的二维矩阵输入和1DCNN模型的一维向量输入, 设置了名为流量矩阵和一维报文两种不同的样本.\n二维流量矩阵样本设计 在预检测阶段提出了一种包含100行82列的二维流量矩阵样本，用于高效收集和监控网络流量，以检测DDoS攻击。由于逐一检测报文效率低且开销大，BCNN模型将整个流量矩阵作为输入，一次性扫描矩阵中的100行报文。当出现DDoS攻击流量时，模型通过感知矩阵中异常的流量态势变化，间接判断网络中是否存在DDoS攻击。\n流量矩阵的Y轴表示连续抓取的100个报文的头部信息，X轴表示每个报文的82个头部字段，其中X1–X54为公共字段，其余字段对应ICMPv6、TCP和UDP的特殊字段。我们根据每个报文的协议类型填充相应字段，空字段以0填充。通过构建由\u0026lt;流量矩阵样本, 矩阵标签\u0026gt;组成的数据集，将含有DDoS攻击报文的矩阵标记为1（恶意），全为正常报文的矩阵标记为0（正常）。同时，通过调整矩阵中DDoS攻击报文的数量，模拟不同强度的DDoS攻击事件，以测试BCNN模型的监控精度变化。\n一维报文样本设计 在深度检测阶段，本文使用1DCNN模型来具体区分网络中的单个报文是否为DDoS攻击流量。因此，1DCNN的数据集由\u0026lt;一维报文样本, 报文标签\u0026gt;构成。我们参照流量矩阵中X轴上的82个字段，针对每个报文形成1×82的固定一维向量作为1DCNN模型的输入。其中，标签(0: 正常, 1: 恶意)表示当前报文是否为DDoS攻击流量。\n两阶段的DDoS防御策略 防御流程 将DDoS攻击防御细化为预检测阶段和深度检测阶段，旨在提升DDoS攻击的响应速度以及流量过滤效率。\n预检测阶段 预检测阶段主要负责监控网络中的DDoS攻击事件，利用BCNN模型的矩阵视野高效地感知网络流量态势变化。当DDoS攻击发生且流量出现异常时，模型能够快速告警。\n深度检测阶段 深度检测阶段在告警后立即介入，使用1DCNN模型对一维报文样本进行检测，区分并过滤混杂在网络中的DDoS攻击报文，提取源信息以进行阻断和缓解。\n为了提高防御效率，本文引入了动态窗口策略。在预检测阶段告警后，计算当前DDoS攻击的“强度”（即攻击报文占总流量的百分比）。当强度大于20%时，深度检测阶段直接抓取网络流量进行检测；当强度小于20%时，则针对预检测阶段标记为恶意的流量矩阵进行检测。时间窗口T的大小根据当前强度与20%阈值的差值动态调整，以平衡检测灵敏度和冗余，设置计数器C，当在连续C个时间窗口内未检测到DDoS攻击时，结束检测过程。\n模型构建 BCNN模型（预检测阶段） BCNN用于预检测阶段，主要任务是通过分析网络流量矩阵来监控DDoS攻击。\n模型结构： 输入层：输入是一个100×82的二维流量矩阵，每一行表示一个报文的头部字段，总共82个字段。 卷积层： 第一个卷积层：7×7的普通卷积核，生成4个特征图（Feature maps），输出大小为94×76。 二值卷积层1（Binary_conv1）：5×5的卷积核，生成8个特征图，输出大小为47×38。 二值卷积层2（Binary_conv2）：3×3的卷积核，生成16个特征图，输出大小为23×19。 二值卷积层3（Binary_conv3）：3×3的卷积核，生成16个特征图，输出大小为11×9。 池化层：在卷积层之间插入了2×2的最大池化层（Max pooling），用于下采样，降低特征图的维度。 全局平均池化（GAP）：在最后一个池化层之后，通过全局平均池化层将16个特征图的维度降低为1维，即每个特征图取平均值，最终输出为16维向量。 输出层：最后是一个全连接层，用于二分类任务，输出为2个节点，分别对应是否发生DDoS攻击的可能性。 graph TD; Input[100×82流量矩阵] \u0026ndash;\u0026gt; Conv1[7×7卷积层]; Conv1 \u0026ndash;\u0026gt; Pool1[Max Pooling]; Pool1 \u0026ndash;\u0026gt; BinaryConv1[5×5二值卷积层]; BinaryConv1 \u0026ndash;\u0026gt; Pool2[Max Pooling]; Pool2 \u0026ndash;\u0026gt; BinaryConv2[3×3二值卷积层]; BinaryConv2 \u0026ndash;\u0026gt; Pool3[Max Pooling]; Pool3 \u0026ndash;\u0026gt; BinaryConv3[3×3二值卷积层]; BinaryConv3 \u0026ndash;\u0026gt; GAP[全局平均池化]; GAP \u0026ndash;\u0026gt; Output[二分类输出];\n1DCNN模型（深度检测阶段） 1DCNN模型用于深度检测阶段，专门负责对单个报文进行精细分类，以判定报文是否为DDoS攻击流量。该模型的设计目标是处理网络中的每一个报文，通过深入分析其头部字段来识别潜在的恶意流量。\n模型结构： 输入层：输入为一个一维报文向量，大小为1×82。该向量包括报文的82个头部字段，每个字段包含了具体的网络信息，如IP地址、端口号、协议类型等。\n卷积层：\n第一个卷积层：使用1×7的卷积核，生成2个特征图，输出大小为1×76。该层提取初始特征，处理报文头部的局部相关性。 第二个卷积层：使用1×5的卷积核，生成4个特征图，输出大小为1×38。进一步缩小数据维度，并提取更多特征。 第三个卷积层：使用1×3的卷积核，生成8个特征图，输出大小为1×19。逐步增加卷积核的深度，提升模型对特征的表达能力。 第四个卷积层：使用1×3的卷积核，生成8个特征图，输出大小为1×9。该层帮助进一步提取细粒度的特征。 池化层：在每个卷积层之间插入1×2的最大池化层（Max pooling），用于降低特征图的维度，减小计算复杂度，同时保留关键特征。\n全局平均池化层（GAP）：与卷积层和池化层配合使用，通过全局平均池化将特征图转换为1维特征向量，减少特征维度，从而简化模型并避免过拟合。\n输出层：最后的输出层是一个全连接层，用于二分类任务，输出大小为2。该层对报文进行分类，判断是否为DDoS攻击报文。\n模型流程图 graph TD; Input[1×82报文向量] \u0026ndash;\u0026gt; Conv1[1×7卷积层]; Conv1 \u0026ndash;\u0026gt; Pool1[Max Pooling]; Pool1 \u0026ndash;\u0026gt; Conv2[1×5卷积层]; Conv2 \u0026ndash;\u0026gt; Pool2[Max Pooling]; Pool2 \u0026ndash;\u0026gt; Conv3[1×3卷积层]; Conv3 \u0026ndash;\u0026gt; Pool3[Max Pooling]; Pool3 \u0026ndash;\u0026gt; Conv4[1×3卷积层]; Conv4 \u0026ndash;\u0026gt; GAP[全局平均池化]; GAP \u0026ndash;\u0026gt; Output[二分类输出];\n","permalink":"https://Clow5211.github.io/posts/blog/blog3/","summary":"IPv6 中一种基于卷积的 DDoS 攻击两阶段防御机制 研究现状 现有的研究内容： 在DDoS攻击防御工作中，针对DDoS攻击事件的监控研究逐渐受到重视。早期的研究，如Yuan等人[14]提出通过在网络中设置互相关观察点，监控DDoS攻击在宏观上引起的时空流量模式变化。Singh等人[15]通过监控流","title":"一种双阶段DDoS攻击检测方式"},{"content":"Building IPv6 Addressing Scheme using Hybrid Duplicate Address Detection to Prevent Denial of Service Attack 1. Duplicate Address Detection (DAD) Whenever a host is assigned an IPv6 address, it performs a DAD check to ensure that no other hosts are already using or vying for the same address. The DAD process typically includes the following steps:\nThe host generates an IPv6 address and marks it as \u0026ldquo;tentative\u0026rdquo;. The host sends a Neighbor Solicitation (NS) message through the Neighbor Discovery Protocol to check if any other device on the network is already using the address. If no Neighbor Advertisement (NA) message is received within a certain time, or the response indicates no conflict, the host can confirm that the address is unique and start using it. If an NA message is received, indicating that the address is already in use, the host must choose another address or take other actions to resolve the conflict. Static IP Address: A static IP address is a long-term assigned IP address for a specific device that does not change over time.\nCurrent defenses against DAD attacks have significant flaws, such as excessive computation, lack of scalability, and the need to modify the protocol.\n2. Denial of Service (DoS) and Man-In-The-Middle (MITM) Attacks Denial of Service (DoS) Attack A DoS attack is a type of attack that aims to make network services unavailable. The goal is to prevent the target server, service, or network from processing legitimate user requests. This is often achieved by:\nTraffic Overload: The attacker sends massive amounts of traffic to the target server, saturating the network bandwidth so that legitimate traffic cannot be processed. Resource Exhaustion: The attacker exploits specific vulnerabilities in the server or service, causing it to consume excessive resources (e.g., CPU, memory), which prevents it from responding to legitimate requests. Service Denial: The attacker sends specific requests that cause the service to crash or enter a state where it can no longer handle other requests. Man-In-The-Middle (MITM) Attack MITM attacks involve an attacker inserting themselves between two communicating parties. The attacker can intercept, modify, and forward the data between them, often without either party knowing. This type of attack usually follows these steps:\nIntercepting Communication: The attacker intercepts data being transmitted between two parties, for example, by creating a fake Wi-Fi network. Impersonation: The attacker pretends to be a legitimate party to establish a trusted connection with one of the communication parties. Data Tampering: The attacker can read, modify, or inject malicious data into the communication without detection. Session Hijacking: The attacker may completely take over the session of one or both parties and perform unauthorized actions. 3. Network Requirements for Hybrid DAD The hybrid DAD method, demonstrated in this study, reduces the risk of DoS attacks during the IPv6 setup process. To enhance privacy and security, IPv6 addresses are typically divided into two parts: the DAD ID (usually the network prefix) and the Node ID (often derived from the device’s MAC address, but can also be randomly generated to improve privacy). This method, known as Privacy Extensions for Addresses, reduces the risk of exposing user privacy through IP addresses.\nAddress Predictability: If the Node ID is fixed or predictable (such as those based on MAC addresses), attackers can more easily guess or track a device\u0026rsquo;s IP address. Using randomly generated Node IDs helps mitigate this risk. Multicast Listening: During the DAD process, address queries are sent using multicast messages, which increases the attack surface. Attackers could potentially listen to these multicast requests to identify new devices on the network or prevent legitimate devices from using their IP addresses by sending false Neighbor Advertisement messages. DAD Conflicts: Attackers can intentionally respond to all DAD queries, causing address configuration failures. This type of attack is known as a DAD conflict attack. 4. The Mechanism of Hybrid Duplicate Address Detection IPv6 addresses are 128 bits long and are typically divided into two 64-bit parts:\nGlobal Routing Prefix (GRP): 64 bits used for network routing. Interface Identifier (IID): 64 bits used to uniquely identify an interface on the local network. The IID is further divided into two 32-bit sections:\nMost Significant Bits (MS-32) Least Significant Bits (LS-32) Each of these sections is further divided into two 16-bit parts for hybrid DAD calculation:\nLS-32 is split into:\nDAD ID (16 bits) Secret ID-1 (16 bits) MS-32 is split into:\nNode ID (16 bits) Secret ID-2 (16 bits) Hybrid DAD Calculation In the DAD process, XOR operations are used to calculate hybrid DAD values to improve security:\nFor Neighbor Solicitation (NS) frames, the LS-16 value is calculated by XORing the DAD ID with Secret ID-1. For Neighbor Advertisement (NA) frames, when a duplicate address is detected, established nodes respond with an NA frame carrying the hybrid MS-16 value, which is the XOR of the Node ID with Secret ID-2. This technique increases privacy and security during address configuration by making it harder for attackers to predict or infer the actual interface identifier.\nExample: Assume the IPv6 Interface ID (IID) is 0000:8a2e:0370:7334.\nMS-32: 0000:8a2e\nNode ID: 0000 Secret ID-2: 8a2e LS-32: 0370:7334\nDAD ID: 0370 Secret ID-1: 7334 XOR Calculation: MS-16 (Hybrid): 0000 XOR 8a2e = 8a2e LS-16 (Hybrid): 0370 XOR 7334 = 7044 5. Algorithm 1: Hybrid DAD IP Configuration Process Initialize hybrid DAD_count and hybrid DAD_timeout. Generate a new IP address: the device attempts to use 0000:8a2e:0370:7334. Broadcast NS_hybrid DAD: the device sends an NS request with the hybrid LS-16 value (7044). Receive NA_hybrid DAD: the device waits for responses from other devices. Loop Detection: If an NA message is received from an established node and the MS-16 value (8a2e) matches, it indicates a potential address conflict. If the conflict persists after reaching the thresholdDAD (max attempts), the device regenerates a new MS value and repeats the process. Timeout or Threshold: if conflicts persist or timeout occurs, the device broadcasts a network error message and reports failure. 6. Algorithm 2: Hybrid DAD Verification Receive NS_hybrid DAD: the device receives an NS request from another device and checks the LS-16 value. Verify LS-16: If the LS-16 value (7044) matches the local configuration, the device sends an NA_hybrid DAD response, indicating an address conflict. If not, the request is discarded, indicating the address is unique. 7. Results and Communication If the DAD process succeeds with no conflicts, the device confirms that the IP address 0000:8a2e:0370:7334 is unique and starts using it for communication. If there are conflicts, the device needs to regenerate either the Node ID or DAD ID and recalculate the XOR values until no conflicts are detected. This process ensures the uniqueness of IPv6 addresses in the network and, with the added security of hybrid DAD (using XOR and Secret IDs), enhances the privacy and security of network communication by preventing common attacks like address spoofing and DAD conflicts.\n","permalink":"https://Clow5211.github.io/posts/blog/blog2/","summary":"Building IPv6 Addressing Scheme using Hybrid Duplicate Address Detection to Prevent Denial of Service Attack 1. Duplicate Address Detection (DAD) Whenever a host is assigned an IPv6 address, it performs a DAD check to ensure that no other hosts are already using or vying for the same address. The DAD process typically includes the following steps: The host generates an IPv6 address and marks it as \u0026ldquo;tentative\u0026rdquo;. The host sends a Neighbor Solicitation (NS) message through the Neighbor Discovery Protocol to check if any other device on the network is already using the address. If no Neighbor Advertisement (NA) message is received within a certain time, or the response indicates no conflict, the host can confirm that the address is unique and start using it. If an NA message is received, indicating that the address is already in use, the","title":"Hybrid Duplicate Address Detection in IPv6 to prevent Denial of Service Attack"},{"content":"0. 摘要 专门设计的、结合两方面的新模型。新的评估测试集SLMTokBench benchmark。\n1. 引言 LLM的卓越表现促进了语音语言模型的发展。在多种语音处理任务中都使用到了离散语音表示。如下图所示。\n语义表征(semantic tokens)通常是自监督的预训练模型，训练目标是掩码语言建模，通过特定中间层对表征进行k-means聚类，表征是一维结构的序列。声学表征(acoustic tokens)通常是神经音频编解码器模型，训练目标是音频重构，通过RVQ(residual vector quantization)进行离散化，表征是由时间步长和量化器两个维度组成的矩阵。\n基于这两种离散语音表征，语音语言模型的建模方法有三种：\n语义表征+外部单元声码器。质量低、声学细节丢失。 以VALL-E这种zero-shot TTS为例的声学表征模型。声学表征中的信息太复杂导致的语音内容不准确。 级联语义表征模型和声学表征模型。级联模型的缺点，以及信息冗余重复、浪费。这三者的表现与作者的模型相比如下表所示。 Accurate Content High-quality Speech Single Tokenizer Semantic LM yes no yes Acoustic LM no yes yes Hierarchical LM yes yes no USLM(thers) no yes yes 因此作者认为理想的语音表征应该保有两个关键特性：\n与文本强对齐。 语音信息的有效保存(损失少)。 因此提出了Speech Language Model Token Benchmark测试集来评估语音表征是否适用于语音语言模型。评估表明语义表征高对齐、低信息，声学表征高信息、低对齐。作者的做法是基于声学表征模型，在RVQ结构中进行信息解耦，通过语义教师指导使得第一个RVQ quantizer生成包含文本信息的表征，后续的quantizer对信息进行补充。\n实验结果表明，USLM在语音重建性能无影响的前提下，在语音处理任务上更强。\n论文贡献为三点:\nSpeechTokenizer，基于Acoustic Tokens保有Semantic Tokens。 SLMTokBench benchmark，适用于评估在语音语言模型上的表现。 USLM，outperforms VALL-E on zero-shot TTS task。 2. 结论 依旧是三点贡献。\n3. 测试集SLMTokBench 根据两个特性来评测模型效果。\n4. SpeechTolenizer 基于LSTM-\u0026gt;BiLSTM的EnCodec，HuBert作为语义教师指导残差量化过程。余弦相似度与伪标签，获得损失。\n","permalink":"https://Clow5211.github.io/posts/read/read1/","summary":"0. 摘要 专门设计的、结合两方面的新模型。新的评估测试集SLMTokBench benchmark。 1. 引言 LLM的卓越表现促进了语音语言模型的发展。在多种语音处理任务中都使用到了离散语音表示。如下图所示。 语义表征(semantic tokens)通常是自监督的预训练模型，训练目标是掩码语","title":"SpeechTokenizer: Unified Speech Tokenizer For Speech Language Models"},{"content":"一. EnCodec 1. 模型任务 EnCodec是在SoundStream模型的基础上提出的，用于实现音频数据的高效压缩。其被提出是为了解决音频数据的实时传输，因为要保证数据传输的实时性，所以需要对音频数据进行压缩，同时也要保证被压缩的质量。该工作就是利用神经网络来解决压缩与恢复工作。\n2. 模型发展 压缩可以追溯到AE(Auto Encoder)模型，是一个编解码模型，由编码器进行压缩，解码器进行恢复。这是一个自监督模型，它只需要对模型的输入x和模型的输出x`进行损失计算即可。\n然而由于AE模型编码器编码出来的向量空间不规整，其无法适用于生成任务，因为解码器并不能识别一个随意的向量。因为为了使编码空间规整，VAE(Variational Auto Encoder)模型被提出。其使编码向量满足正态分布，这样编码器也可以识别正态分布的向量了，进而实现随机生成任务。\n但是实验结果表明VAE模型的生成并不理想，进而被认为连续的编码向量不如转换为离散。这种类似选项或者是词汇的输入更符合人类创作的过程。VQ-VAE(Vector Quantised - Variational Auto Encoder)模型使用类似嵌入层(Embedding)的操作让解码器能够识别离散化的向量，该层被称作嵌入空间(embedding space)，在后续文章中被称作码本(codebook)。然而这个离散向量的空间又变成不好采样的了，为了解决这个问题作者训练了一个生成模型学习生成离散样本，进而解决上述问题。使用logit获取离散向量再把它映射成连续向量被认为是很多余的操作，在VQ-VAE模型中使用编码器的输出向量找寻码本中距离最近的向量进行替换，生成离散向量便是如此过程。那么问题又来了，反向传播怎么办？VQ-VAE基于“straight-through”技术使用了sg(stop gradient)运算解决了这个问题，细节不进行研究了。后续该运算也解决了码本训练的问题。\n3. 模型结构 模型框架图如下所示，主要由Encoder、Quantizer、Decoder以及Discriminator四部分构成，共计算了6处损失函数。\n编码器和解码器的设计基本是镜像的，由1D卷积层、B个卷积块、两层LSTM和最后一个1D卷积层组成。模型支持流式与非流式，只是padding和归一化不同。\n量化器是由RVQ(Residual Vector Quantization，残差向量量化)实现的，那么它与VQ-VAE中的VQ有何不同呢？单个码本经原作者计算是远远不够的，这样的话需要多个码本来解决问题，多个quantization block对应多个码本，之间用残差连接，相当于后面的quantization block量化的是前一个的误差，具体细节可在参考文献中了解。该部分还加入了一个较小的语言模型，根据当前时刻的RVQ向量来预测下一个时刻的RVQ向量，从而提前完成语音解码的工作。其加速了解码速度。\n模型使用多个判别器来评估解码器恢复的效果，这里用到了GAN模型。\n4. 参考文献 知乎：https://zhuanlan.zhihu.com/p/633744455\n知乎：https://zhuanlan.zhihu.com/p/672684663\n论文链接：https://arxiv.org/pdf/2210.13438\n二. VALL-E 1. 模型任务：语音合成大模型 上篇作者认为连续的音频数据经过Encodec压缩后变成了离散的数据，那就可以将这些离散的ID视作一个个token，用大量的语音数据训练出一个语音的“大语言模型”。微软推出的VALL-E和VALL-E-X模型做的就是这样的工作。zero-shot TTS!!!\n2. 模型过程 EnCodec由于将语音进行了压缩，重建质量高和压缩程度大，很好地解决了语音和文本在信息密度和长度上的巨大差异。并且Encodec有现成的解码器能够将离散表征转换为声音波形，无需训练额外的声码器。\nRQV中生成的离散向量被称为声学词元(acoustic tokens)，与被音素转换模块由文本提示词转换成的因素一同送入模型，预测后续的声学词元，进而被解码器转化为声学波形。\n知乎作者给出的结论：VALLE就是使用Encodec的离散表征来做acoustic tokens，堆大数据来做语音领域的大语言模型。\n3. 参考文献 知乎：https://zhuanlan.zhihu.com/p/672852107\n论文链接：https://arxiv.org/pdf/2301.02111\ndemo：https://lifeiteng.github.io/valle/index.html\n","permalink":"https://Clow5211.github.io/posts/blog/blog1/","summary":"一. EnCodec 1. 模型任务 EnCodec是在SoundStream模型的基础上提出的，用于实现音频数据的高效压缩。其被提出是为了解决音频数据的实时传输，因为要保证数据传输的实时性，所以需要对音频数据进行压缩，同时也要保证被压缩的质量。该工作就是利用神经网络来解决压缩与恢复工作。 2. 模型发展 压","title":"EnCodec在大语言模型上的调研"},{"content":"1. 修改 需要进行更改的文件为layouts/partials/post_meta.html、layouts/partials/author.html、layouts/partials/extend_head.html以及params。\nlayouts/partials/post_meta.html的更改链接为https://github.com/xyming108/sulv-hugo-papermod/blob/main/layouts/partials/post_meta.html，其更改结果如下：\n\u0026lt;!--如果单独复制这段代码，需要从 extend_head.html 中找到 font-awesome 引入，如下--\u0026gt; \u0026lt;!--\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css\u0026#34;\u0026gt;--\u0026gt; \u0026lt;style\u0026gt; i[id*=\u0026#34;post_meta_style\u0026#34;] { display: flex; align-items: center; margin: 0 0 10px 0; } .parent-post-meta { display: flex; flex-wrap: wrap; opacity: 0.8; } \u0026lt;/style\u0026gt; \u0026lt;span class=\u0026#34;parent-post-meta\u0026#34;\u0026gt; \u0026lt;span id=\u0026#34;post_meta_style_1\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;fa fa-calendar-check-o\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt; {{- (.Date.Format (default \u0026#34;January 2, 2006\u0026#34; .Site.Params.DateFormat)) }} \u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;!-- \u0026lt;span id=\u0026#34;post_meta_style_2\u0026#34;\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;span class=\u0026#34;fa fa-calendar-plus-o\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;span\u0026gt;--\u0026gt; \u0026lt;!-- \u0026amp;nbsp;更新\u0026amp;nbsp;{{- (.Lastmod.Format (.Site.Params.dateFormat | default \u0026#34;2006-01-02\u0026#34;)) }}--\u0026gt; \u0026lt;!-- \u0026amp;nbsp;|\u0026amp;nbsp;--\u0026gt; \u0026lt;!-- \u0026lt;/span\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;/span\u0026gt;--\u0026gt; \u0026lt;span id=\u0026#34;post_meta_style_3\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;fa fa-file-word-o\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt; {{- .WordCount }}字 \u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;post_meta_style_4\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;fa fa-clock-o\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt; {{- .ReadingTime }}分钟 \u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;post_meta_style_5\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;fa fa-user-o\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt; {{- with (partial \u0026#34;author.html\u0026#34; .) }} {{- . }} {{- end }} \u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;post_meta_style_6\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;fa fa-tags\u0026#34; style=\u0026#34;opacity: 0.8\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt; {{- if .Params.tags }} \u0026lt;span class=\u0026#34;post-tags-meta\u0026#34;\u0026gt; {{- range $index, $value := ($.GetTerms \u0026#34;tags\u0026#34;) }} {{- if eq $index 0}} \u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34; style=\u0026#34;color: var(--secondary)!important;\u0026#34;\u0026gt;{{ .LinkTitle }}\u0026lt;/a\u0026gt; {{- else }} \u0026amp;nbsp;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34; style=\u0026#34;color: var(--secondary)!important;\u0026#34;\u0026gt;{{ .LinkTitle }}\u0026lt;/a\u0026gt; {{- end }} {{- end }} \u0026lt;/span\u0026gt; {{- end }} \u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt; 2. 理解 摸鱼ing\n","permalink":"https://Clow5211.github.io/posts/tech/tech/","summary":"1. 修改 需要进行更改的文件为layouts/partials/post_meta.html、layouts/partials/author.html、layouts/partials/extend_head.html以及params。 layouts/partials/post_me","title":"博客模板"},{"content":"","permalink":"https://Clow5211.github.io/posts/read/read/","summary":"","title":"Text-to-Text Transfer Transformer(T5)"},{"content":"关于我\n性别: 男 职业: 研究僧 运动: 跑步、乒乓球、爬山 ","permalink":"https://Clow5211.github.io/about/","summary":"关于我 性别: 男 职业: 研究僧 运动: 跑步、乒乓球、爬山","title":"🙋🏻‍♂️关于"},{"content":"","permalink":"https://Clow5211.github.io/posts/blog/blog/","summary":"","title":"Blog"},{"content":"","permalink":"https://Clow5211.github.io/posts/life/life/","summary":"","title":"Life"},{"content":"\r👉友链格式\r名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群\r787018782\n","permalink":"https://Clow5211.github.io/links/","summary":"👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内 👉Hugo博客交流群 787018782","title":"🤝友链"}]